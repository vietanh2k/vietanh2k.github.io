# -*- coding: utf-8 -*-
"""wiener_attack.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19ddoWJ1kA7gpiYURt5Lfzf0uqnNLSYE9

install gmpy2 in google colab
"""

!sudo apt-get install python3 python-dev python3-dev \
     build-essential libssl-dev libffi-dev \
     libxml2-dev libxslt1-dev zlib1g-dev \
     python-pip
!sudo apt install libmpc-dev
!sudo apt install python3-pip
!pip install gmpy2

"""# Generate big prime"""

import random
import time
from gmpy2 import *

random.seed(time.time())

def gen_prime(bit):   # nhập vào số bit
    num_prime = random.randint(1<< bit, 1<< (bit+1)) | 1
    while is_prime(num_prime) == False:
        num_prime = random.randint(1<< bit, 1<< (bit+1)) | 1

    return num_prime


start_time = time.time()
print(gen_prime(3072))

end_time = time.time()
print('thời gian chạy chương trình: ', end_time - start_time)

"""# RSA"""

import numpy as np
import random
import time
from gmpy2 import *
# import generate_prime

random.seed(time.time())

class RSA(object):
    def __init__(self, bit, bit_d = 0):
        p, q = gen_prime( div(bit, 2) ), gen_prime( bit*2 )
        self.n = mul(p, q)
        p_q = mul(p-1, q-1)
        self.d = random.randint(1<< bit, 1<< (bit+1)) |1    if bit_d == 0 else random.randint(1<< bit_d, 1<< (bit_d+1)) |1

        while ( gcd(p_q, self.d) != 1):
            self.d = random.randint(1<< bit, 1<< (bit+1)) |1    if bit_d == 0 else random.randint(1<< bit_d, 1<< (bit_d+1)) |1

        self.e = invert(self.d, p_q)
        print('n = %d'  %(self.n))
        print('e = %d'  %(self.e))
        print('d = %d'  %(self.d))
        print()
        # print('d = %d'  %(self.d))

    def encode(self, message):
        c = pow(message, self.e, self.n)
        return c

    def decode(self, cipher):
        d = pow(cipher, self.d, self.n)
        return d

    
if __name__ == '__main__':
    time_0 = time.time()
    bit = 2048      
    rsa = RSA(bit, 512)

    time_1 = time.time()
    mess = random.randint(1<< bit, 1<< (bit+1))
    print('\nmessage = %d'  %(mess) )

    cipher = rsa.encode( message = mess)
    print( 'cipher = %d'  %(cipher) )

    time_2 = time.time()
    print( 'decode  = %d'  %(rsa.decode(cipher = cipher)) )

    time_3 = time.time()

    print('\nthời gian sinh khóa: %f' %(time_1 - time_0) )
    print('thời gian mã hóa: %f' %(time_2 - time_1) )
    print('thời gian giải mã: %f' %(time_3 - time_2))

"""# Wiener Attack (small d)"""

import sys
from sympy.solvers import solve
from sympy import Symbol


class WienerAttack(object):
    def rational_to_contfrac(self, x, y):
        a = x // y
        if a * y == x:
            return [a]
        else:
            pquotients = self.rational_to_contfrac(y, x - a * y)
            pquotients.insert(0, a)
            return pquotients

    def convergents_from_contfrac(self, frac):
        convs = []
        for i in range(len(frac)):
            convs.append(self.contfrac_to_rational(frac[0:i]))
        return convs

    def contfrac_to_rational(self, frac):
        if len(frac) == 0:
            return (0, 1)
        elif len(frac) == 1:
            return (frac[0], 1)
        else:
            remainder = frac[1:len(frac)]
            (num, denom) = self.contfrac_to_rational(remainder)
            return (frac[0] * num + denom, num)

    def is_perfect_square(self, n):
        h = n & 0xF
        if h > 9:
            return -1

        if (h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8):
            t = self.isqrt(n)
            if t*t == n:
                return t
            else:
                return -1

        return -1

    def isqrt(self, n):
        if n == 0:
            return 0
        a, b = divmod(n.bit_length(), 2)
        x = 2**(a+b)
        while True:
            y = (x + n//x)//2
            if y >= x:
                return x
            x = y

    def __init__(self, n, e):
        self.d = None
        self.p = None
        self.q = None
        sys.setrecursionlimit(100000)
        frac = self.rational_to_contfrac(e, n)
        convergents = self.convergents_from_contfrac(frac)

        for (k, d) in convergents:
            if k != 0 and (e * d - 1) % k == 0:
                phi = (e * d - 1) // k
                s = n - phi + 1
                discr = s*s - 4*n
                if(discr >= 0):
                    t = self.is_perfect_square(discr)
                    if t != -1 and (s + t) % 2 == 0:
                        self.d = d
                        x = Symbol('x')
                        roots = solve(x**2 - s * x + n, x)
                        if len(roots) == 2:
                            self.p = roots[0]
                            self.q = roots[1]
                        break


def main():
    
    rsa = RSA(2048, bit_d = 256)
    n, e = rsa.n, rsa.e
    Wiener = WienerAttack(n,e)
    print('d =', Wiener.d)
    print('p =', Wiener.p)
    print('q =', Wiener.q)


if __name__ == '__main__':
    main()

